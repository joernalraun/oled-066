{"entries":[{"timestamp":1764929994629,"editorVersion":"8.1.7","changes":[{"type":"edited","filename":"main.blocks","patch":[{"start1":0,"length1":234,"diffs":[[1,"<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <block type=\"pxt-on-start\"></block>\n  <block type=\"device_forever\"></block>\n</xml>"]]}]},{"type":"edited","filename":"main.ts","patch":[{"start1":0,"length1":33,"diffs":[[1,"\n"]]}]},{"type":"edited","filename":"pxt.json","patch":[{"start1":67,"length1":39,"diffs":[[1,"        \"core\": \"*\"\n"]]},{"start1":151,"length1":41,"diffs":[[1,"        \"README.md\"\n"]]},{"start1":178,"length1":75,"diffs":[[1,"    \"additionalFilePaths\": []\n"]]}]},{"type":"added","filename":"test.ts","value":"// Hier kann man Tests durchf√ºhren; diese Datei wird nicht kompiliert, wenn dieses Paket als Erweiterung verwendet wird.\n"},{"type":"added","filename":"custom.ts","value":"/**\n * MakeCode extension for controlling OLED display using BBC micro:bit.\n * Adapted for 64x48 pixel displays from original 128x64 version.\n * License: MIT\n * Maintainer: Pythom1234 (original), adapted for 64x48\n * [https://github.com/Pythom1234/pxt-oled](https://github.com/Pythom1234/pxt-oled)\n */\n\n//% icon=\"\\uf26c\" color=#0000ff block=\"OLED\"\nnamespace oled {\n    const ADDR = 0x3C\n    const WIDTH = 64\n    const HEIGHT = 48\n    const PAGES = HEIGHT / 8  // 6 pages\n    let screen = pins.createBuffer(1 + WIDTH * PAGES)\n    let charset: number[][] = []\n    let charsetIndex: string[] = []\n\n    function indexFor(x: number, y: number): number {\n        return Math.floor(y / 8) * WIDTH + x + 1\n    }\n\n    // From microbit/micropython Chinese community\n    function cmd1(cmd1: number): void {\n        let buffer = pins.createBuffer(2)\n        buffer[0] = 0x00\n        buffer[1] = cmd1\n        pins.i2cWriteBuffer(ADDR, buffer)\n    }\n    // From microbit/micropython Chinese community\n    function cmd2(cmd1: number, cmd2: number): void {\n        let buffer = pins.createBuffer(3)\n        buffer[0] = 0x00\n        buffer[1] = cmd1\n        buffer[2] = cmd2\n        pins.i2cWriteBuffer(ADDR, buffer)\n    }\n    // From microbit/micropython Chinese community\n    function cmd3(cmd1: number, cmd2: number, cmd3: number): void {\n        let buffer = pins.createBuffer(4)\n        buffer[0] = 0x00\n        buffer[1] = cmd1\n        buffer[2] = cmd2\n        buffer[3] = cmd3\n        pins.i2cWriteBuffer(ADDR, buffer)\n    }\n    function showbit(bit: number, shift: number): number {\n        if (bit & (1 << shift)) { }\n        else {\n            bit += 1 << shift\n        }\n        return bit\n    }\n    function hidebit(bit: number, shift: number): number {\n        if (bit & (1 << shift)) {\n            bit -= 1 << shift\n        }\n        return bit\n    }\n    function getbit(bits: number, shift: number): number {\n        return (bits >> shift) & 1;\n    }\n\n    /**\n     * Initialize OLED display, this command must be called at the start of the program.\n     */\n    //% block=\"init OLED display\"\n    //% weight=101\n    export function init(): void {\n        screen = pins.createBuffer(1 + WIDTH * PAGES)\n        cmd1(0xAE)              // Display off\n        cmd1(0xA4)              // Resume to RAM content\n        cmd2(0xD5, 0x80)        // Clock divide ratio/oscillator frequency\n        cmd2(0xA8, HEIGHT - 1)  // Multiplex ratio: 47 (for 48 lines)\n        cmd2(0xD3, 0x00)        // Display offset\n        cmd1(0x40)              // Start line = 0\n        cmd2(0x8D, 0x14)        // Charge pump enable\n        cmd2(0x20, 0x00)        // Horizontal addressing mode\n\n        // Set display area to exactly 64x48 (6 pages)\n        cmd3(0x21, 0x00, WIDTH - 1)   // Column address: 0 to 63\n        cmd3(0x22, 0x00, PAGES - 1)   // Page address: 0 to 5\n\n        cmd1(0xA1)              // Segment remap A0/A1\n        cmd1(0xC8)              // COM scan direction remap\n        cmd2(0xDA, 0x12)        // Sequential COM pin configuration\n        cmd2(0x81, 0xFF)        // Contrast\n        cmd2(0xD9, 0xF1)        // Precharge period\n        cmd2(0xDB, 0x40)        // VCOM deselect level\n        cmd1(0xA6)              // Normal (not inverted) display\n        cmd2(0xD6, 0x00)        // Zoom mode off\n        cmd1(0xAF)              // Display on\n\n        clear(false)\n        draw()\n    }\n\n    /**\n     * Sets the luminance level to the specified value.\n     * @param contrast luminance level, eg: 255\n     */\n    //% block=\"set contrast $contrast\"\n    //% contrast.defl=255\n    //% contrast.min=0\n    //% contrast.max=255\n    //% weight=100\n    export function setContrast(contrast: number): void {\n        cmd2(0x81, contrast)\n    }\n\n    /**\n     * Fills the display buffer with specified color.\n     * You need to call `draw` to see the changes.\n     * @param color filling color (usually `false`)\n     */\n    //% block=\"clear $color\"\n    //% color.defl=false\n    //% weight=99\n    export function clear(color: boolean): void {\n        screen.fill((color) ? 0xFF : 0)\n    }\n\n    /**\n     * Sends buffer to OLED display.\n     * This command must be called whenever you want to show something on the OLED display.\n     */\n    //% block=\"draw\"\n    //% weight=98\n    export function draw(): void {\n        pins.i2cWriteNumber(ADDR, 0xB0, NumberFormat.UInt16BE)\n        pins.i2cWriteNumber(ADDR, 0x00, NumberFormat.UInt16BE)\n        pins.i2cWriteNumber(ADDR, 0x10, NumberFormat.UInt16BE)\n        screen[0] = 0x40\n        pins.i2cWriteBuffer(ADDR, screen, false)\n    }\n\n    /**\n     * Sets pixel at x y to specified color color.\n     * You need to call `draw` to see the changes.\n     * @param x coordinate x (increases towards the right)\n     * @param y coordinate y (increases downwards)\n     * @param color color of pixel\n     */\n    //% block=\"set pixel at x $x y $y to $color\"\n    //% color.defl=true\n    //% weight=97\n    export function setPx(x: number, y: number, color: boolean): void {\n        const index = indexFor(x, y)\n        if (index > 0 && index < screen.length && x >= 0 && x < WIDTH && y >= 0 && y < HEIGHT) {\n            screen[index] = (color) ? showbit(screen[index], (y % 8)) : hidebit(screen[index], (y % 8))\n        }\n    }\n\n    /**\n     * Toggles pixel at x y, it means that `true` will be `false` and vice versa.\n     * You need to call `draw` to see the changes.\n     * @param x coordinate x (increases towards the right)\n     * @param y coordinate y (increases downwards)\n     */\n    //% block=\"toggle pixel at x $x y $y\"\n    //% weight=96\n    export function togglePx(x: number, y: number): void {\n        const index = indexFor(x, y)\n        if (index > 0 && index < screen.length && x >= 0 && x < WIDTH && y >= 0 && y < HEIGHT) {\n            screen[index] = (!px(x, y)) ? showbit(screen[index], (y % 8)) : hidebit(screen[index], (y % 8))\n        }\n    }\n\n    /**\n     * Returns color of pixel at x y in buffer.\n     * @param x coordinate x (increases towards the right)\n     * @param y coordinate y (increases downwards)\n     */\n    //% block=\"pixel at x $x y $y\"\n    //% weight=95\n    export function px(x: number, y: number): boolean {\n        const index = indexFor(x, y)\n        if (index > 0 && index < screen.length && x >= 0 && x < WIDTH && y >= 0 && y < HEIGHT) {\n            return getbit(screen[index], (y % 8)) == 1\n        } else {\n            return false\n        }\n    }\n\n    /**\n     * Draws text with upper left corner at x y.\n     * Text has fixed width (8 px).\n     * You need to call `draw` to see the changes.\n     * @param text text to draw (not all characters are implemented yet)\n     * @param x coordinate x of upper left corner of text (increases towards the right)\n     * @param y coordinate y of upper left corner of text (increases downwards)\n     * @param color color of text\n     * @param toggle sets whether to use pixel switching instead of setting the pixel to a specific color (if `true`, `color` means nothing)\n     */\n    //% block=\"draw text $text at|x $x|y $y|color $color|toggle $toggle\"\n    //% color.defl=true\n    //% toggle.defl=false\n    //% weight=94\n    export function drawText(text: string, x: number, y: number, color: boolean, toggle: boolean): void {\n        const font = [\n            [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],\n            [0x00, 0x10, 0x10, 0x10, 0x10, 0x10, 0x00, 0x10, 0x10, 0x00, 0x00],\n            [0x24, 0x24, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],\n            [0x00, 0x24, 0x24, 0x7E, 0x24, 0x7E, 0x24, 0x24, 0x00, 0x00, 0x00],\n            [0x00, 0x08, 0x1C, 0x2A, 0x18, 0x0C, 0x2A, 0x1C, 0x08, 0x00, 0x00],\n            [0x00, 0x24, 0x5C, 0x28, 0x08, 0x10, 0x14, 0x2A, 0x24, 0x00, 0x00],\n            [0x00, 0x10, 0x28, 0x28, 0x10, 0x2A, 0x44, 0x44, 0x3A, 0x00, 0x00],\n            [0x08, 0x08, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],\n            [0x04, 0x08, 0x08, 0x10, 0x10, 0x10, 0x10, 0x08, 0x08, 0x04, 0x00],\n            [0x20, 0x10, 0x10, 0x08, 0x08, 0x08, 0x08, 0x10, 0x10, 0x20, 0x00],\n            [0x00, 0x08, 0x2A, 0x1C, 0x1C, 0x2A, 0x08, 0x00, 0x00, 0x00, 0x00],\n            [0x00, 0x00, 0x00, 0x08, 0x08, 0x3E, 0x08, 0x08, 0x00, 0x00, 0x00],\n            [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x08, 0x10, 0x00],\n            [0x00, 0x00, 0x00, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x00, 0x00, 0x00],\n            [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x10, 0x00, 0x00],\n            [0x04, 0x04, 0x08, 0x08, 0x08, 0x10, 0x10, 0x10, 0x20, 0x20, 0x00],\n            [0x00, 0x1C, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x1C, 0x00, 0x00],\n            [0x00, 0x08, 0x18, 0x28, 0x08, 0x08, 0x08, 0x08, 0x3E, 0x00, 0x00],\n            [0x00, 0x1C, 0x22, 0x02, 0x04, 0x08, 0x10, 0x20, 0x3E, 0x00, 0x00],\n            [0x00, 0x1C, 0x22, 0x02, 0x0C, 0x02, 0x02, 0x22, 0x1C, 0x00, 0x00],\n            [0x00, 0x04, 0x0C, 0x14, 0x14, 0x24, 0x3E, 0x04, 0x04, 0x00, 0x00],\n            [0x00, 0x3E, 0x20, 0x20, 0x3C, 0x22, 0x02, 0x22, 0x1C, 0x00, 0x00],\n            [0x00, 0x0C, 0x10, 0x20, 0x3C, 0x22, 0x22, 0x22, 0x1C, 0x00, 0x00],\n            [0x00, 0x3E, 0x02, 0x04, 0x08, 0x08, 0x10, 0x10, 0x10, 0x00, 0x00],\n            [0x00, 0x1C, 0x22, 0x22, 0x1C, 0x22, 0x22, 0x22, 0x1C, 0x00, 0x00],\n            [0x00, 0x1C, 0x22, 0x22, 0x22, 0x1E, 0x02, 0x04, 0x18, 0x00, 0x00],\n            [0x00, 0x00, 0x00, 0x10, 0x10, 0x00, 0x00, 0x10, 0x10, 0x00, 0x00],\n            [0x00, 0x00, 0x00, 0x10, 0x10, 0x00, 0x00, 0x10, 0x10, 0x20, 0x00],\n            [0x00, 0x00, 0x04, 0x08, 0x10, 0x20, 0x10, 0x08, 0x04, 0x00, 0x00],\n            [0x00, 0x00, 0x00, 0x00, 0x7E, 0x00, 0x7E, 0x00, 0x00, 0x00, 0x00],\n            [0x00, 0x00, 0x20, 0x10, 0x08, 0x04, 0x08, 0x10, 0x20, 0x00, 0x00],\n            [0x00, 0x38, 0x44, 0x08, 0x10, 0x10, 0x00, 0x10, 0x10, 0x00, 0x00],\n            [0x00, 0x3C, 0x42, 0x4E, 0x52, 0x52, 0x4E, 0x40, 0x3C, 0x00, 0x00],\n            [0x00, 0x18, 0x24, 0x42, 0x42, 0x7E, 0x42, 0x42, 0x42, 0x00, 0x00],\n            [0x00, 0x7C, 0x42, 0x42, 0x7C, 0x42, 0x42, 0x42, 0x7C, 0x00, 0x00],\n            [0x00, 0x3C, 0x42, 0x40, 0x40, 0x40, 0x40, 0x42, 0x3C, 0x00, 0x00],\n            [0x00, 0x7C, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x7C, 0x00, 0x00],\n            [0x00, 0x3E, 0x20, 0x20, 0x3C, 0x20, 0x20, 0x20, 0x3E, 0x00, 0x00],\n            [0x00, 0x3E, 0x20, 0x20, 0x20, 0x3C, 0x20, 0x20, 0x20, 0x00, 0x00],\n            [0x00, 0x3C, 0x42, 0x40, 0x4E, 0x42, 0x42, 0x42, 0x3C, 0x00, 0x00],\n            [0x00, 0x42, 0x42, 0x42, 0x7E, 0x42, 0x42, 0x42, 0x42, 0x00, 0x00],\n            [0x00, 0x3E, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x3E, 0x00, 0x00],\n            [0x00, 0x1E, 0x04, 0x04, 0x04, 0x04, 0x04, 0x44, 0x38, 0x00, 0x00],\n            [0x00, 0x22, 0x24, 0x28, 0x30, 0x30, 0x28, 0x24, 0x22, 0x00, 0x00],\n            [0x00, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x3E, 0x00, 0x00],\n            [0x00, 0x41, 0x63, 0x55, 0x55, 0x49, 0x49, 0x41, 0x41, 0x00, 0x00],\n            [0x00, 0x42, 0x62, 0x52, 0x52, 0x4A, 0x4A, 0x46, 0x42, 0x00, 0x00],\n            [0x00, 0x3C, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x3C, 0x00, 0x00],\n            [0x00, 0x7C, 0x42, 0x42, 0x42, 0x7C, 0x40, 0x40, 0x40, 0x00, 0x00],\n            [0x00, 0x3C, 0x42, 0x42, 0x42, 0x42, 0x52, 0x4A, 0x3C, 0x02, 0x00],\n            [0x00, 0x7C, 0x42, 0x42, 0x42, 0x7C, 0x48, 0x44, 0x42, 0x00, 0x00],\n            [0x00, 0x3C, 0x42, 0x40, 0x3C, 0x02, 0x02, 0x42, 0x3C, 0x00, 0x00],\n            [0x00, 0x3E, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x00, 0x00],\n            [0x00, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x3C, 0x00, 0x00],\n            [0x00, 0x41, 0x41, 0x22, 0x22, 0x14, 0x14, 0x08, 0x08, 0x00, 0x00],\n            [0x00, 0x41, 0x41, 0x41, 0x49, 0x49, 0x49, 0x49, 0x36, 0x00, 0x00],\n            [0x00, 0x63, 0x22, 0x14, 0x08, 0x08, 0x14, 0x22, 0x63, 0x00, 0x00],\n            [0x00, 0x41, 0x41, 0x22, 0x14, 0x08, 0x08, 0x08, 0x08, 0x00, 0x00],\n            [0x00, 0x7E, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x7E, 0x00, 0x00],\n            [0x1C, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x1C, 0x00],\n            [0x20, 0x20, 0x10, 0x10, 0x10, 0x08, 0x08, 0x08, 0x04, 0x04, 0x00],\n            [0x38, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x38, 0x00],\n            [0x00, 0x00, 0x00, 0x08, 0x14, 0x22, 0x00, 0x00, 0x00, 0x00, 0x00],\n            [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7E, 0x00, 0x00],\n            [0x08, 0x08, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],\n            [0x00, 0x00, 0x00, 0x3C, 0x02, 0x3E, 0x42, 0x42, 0x3D, 0x00, 0x00],\n            [0x00, 0x40, 0x40, 0x5C, 0x62, 0x42, 0x42, 0x42, 0x7C, 0x00, 0x00],\n            [0x00, 0x00, 0x00, 0x3C, 0x42, 0x40, 0x40, 0x42, 0x3C, 0x00, 0x00],\n            [0x00, 0x02, 0x02, 0x3A, 0x46, 0x42, 0x42, 0x42, 0x3E, 0x00, 0x00],\n            [0x00, 0x00, 0x00, 0x3C, 0x42, 0x7E, 0x40, 0x42, 0x3C, 0x00, 0x00],\n            [0x00, 0x0E, 0x10, 0x10, 0x3C, 0x10, 0x10, 0x10, 0x10, 0x00, 0x00],\n            [0x00, 0x00, 0x04, 0x38, 0x44, 0x44, 0x38, 0x40, 0x3C, 0x42, 0x3C],\n            [0x00, 0x40, 0x40, 0x5C, 0x62, 0x42, 0x42, 0x42, 0x42, 0x00, 0x00],\n            [0x08, 0x08, 0x00, 0x38, 0x08, 0x08, 0x08, 0x08, 0x3E, 0x00, 0x00],\n            [0x04, 0x04, 0x00, 0x1C, 0x04, 0x04, 0x04, 0x04, 0x04, 0x44, 0x38],\n            [0x00, 0x40, 0x40, 0x44, 0x48, 0x70, 0x48, 0x44, 0x42, 0x00, 0x00],\n            [0x00, 0x38, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x3E, 0x00, 0x00],\n            [0x00, 0x00, 0x00, 0x76, 0x49, 0x49, 0x49, 0x41, 0x41, 0x00, 0x00],\n            [0x00, 0x00, 0x00, 0x5C, 0x62, 0x42, 0x42, 0x42, 0x42, 0x00, 0x00],\n            [0x00, 0x00, 0x00, 0x3C, 0x42, 0x42, 0x42, 0x42, 0x3C, 0x00, 0x00],\n            [0x00, 0x00, 0x00, 0x5C, 0x62, 0x42, 0x42, 0x42, 0x7C, 0x40, 0x40],\n            [0x00, 0x00, 0x00, 0x3E, 0x42, 0x42, 0x42, 0x46, 0x3A, 0x02, 0x02],\n            [0x00, 0x00, 0x00, 0x6E, 0x32, 0x20, 0x20, 0x20, 0x20, 0x00, 0x00],\n            [0x00, 0x00, 0x00, 0x3C, 0x42, 0x3C, 0x02, 0x42, 0x3C, 0x00, 0x00],\n            [0x00, 0x10, 0x10, 0x3C, 0x10, 0x10, 0x10, 0x12, 0x0C, 0x00, 0x00],\n            [0x00, 0x00, 0x00, 0x42, 0x42, 0x42, 0x42, 0x46, 0x3A, 0x00, 0x00],\n            [0x00, 0x00, 0x00, 0x22, 0x22, 0x14, 0x14, 0x08, 0x08, 0x00, 0x00],\n            [0x00, 0x00, 0x00, 0x41, 0x41, 0x49, 0x49, 0x49, 0x36, 0x00, 0x00],\n            [0x00, 0x00, 0x00, 0x66, 0x24, 0x18, 0x18, 0x24, 0x66, 0x00, 0x00],\n            [0x00, 0x00, 0x00, 0x63, 0x22, 0x22, 0x14, 0x0C, 0x08, 0x48, 0x30],\n            [0x00, 0x00, 0x00, 0x7E, 0x04, 0x08, 0x10, 0x20, 0x7E, 0x00, 0x00],\n            [0x0C, 0x10, 0x10, 0x08, 0x30, 0x08, 0x10, 0x10, 0x10, 0x0C, 0x00],\n            [0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x00],\n            [0x30, 0x08, 0x08, 0x10, 0x0C, 0x10, 0x08, 0x08, 0x08, 0x30, 0x00],\n            [0x00, 0x00, 0x00, 0x32, 0x4C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]\n        ]\n        let line = 0\n        let lineStart = 0\n        for (let i = 0; i < text.length; i++) {\n            if (text[i] == '\\n') {\n                line++\n                lineStart = i + 1\n            } else if (charsetIndex.indexOf(text[i]) !== -1) {\n                for (let j = 0; j < 11; j++) {\n                    for (let k = 0; k < 8; k++) {\n                        if (charset[charsetIndex.indexOf(text[i])][j] & (0x01 << k)) {\n                            if (toggle) {\n                                togglePx(x + ((i - lineStart) * 8) + (8 - k), y + (line * 10) + j)\n                            } else {\n                                setPx(x + ((i - lineStart) * 8) + (8 - k), y + (line * 10) + j, color)\n                            }\n                        }\n                    }\n                }\n            } else if (text[i].charCodeAt(0) < 128 && text[i].charCodeAt(0) >= 32) {\n                for (let j = 0; j < 11; j++) {\n                    for (let k = 0; k < 8; k++) {\n                        if (font[text[i].charCodeAt(0) - 32][j] & (0x01 << k)) {\n                            if (toggle) {\n                                togglePx(x + ((i - lineStart) * 8) + (8 - k), y + (line * 10) + j)\n                            } else {\n                                setPx(x + ((i - lineStart) * 8) + (8 - k), y + (line * 10) + j, color)\n                            }\n                        }\n                    }\n                }\n            } else {\n            }\n            basic.pause(1)\n        }\n    }\n\n    /**\n     * Draws rectangle.\n     * You need to call `draw` to see the changes.\n     * @param x1 coordinate x of upper left corner of rectangle (increases towards the right)\n     * @param y1 coordinate y of upper left corner of rectangle (increases downwards)\n     * @param x2 coordinate x of lower right corner of rectangle (increases towards the right)\n     * @param y2 coordinate y of lower right corner of rectangle (increases downwards)\n     * @param color color of rectangle\n     * @param fill sets whether only the outline or also the fill of the rectangle is drawn\n     * @param toggle sets whether to use pixel switching instead of setting the pixel to a specific color (if `true`, `color` means nothing)\n     */\n    //% block=\"draw rect at|x1 $x1|y1 $y1|x2 $x2|y2 $y2|color $color|fill $fill|toggle $toggle\"\n    //% color.defl=true\n    //% fill.defl=false\n    //% toggle.defl=false\n    //% weight=93\n    export function drawRect(x1: number, y1: number, x2: number, y2: number, color: boolean, fill: boolean, toggle: boolean): void {\n        if (fill) {\n            for (let x = x1; x <= x2 && x < WIDTH; x++) {\n                for (let y = y1; y <= y2 && y < HEIGHT; y++) {\n                    if (toggle) {\n                        togglePx(x, y)\n                    } else {\n                        setPx(x, y, color)\n                    }\n                }\n            }\n        }\n        else {\n            for (let x = x1; x <= x2 && x < WIDTH; x++) {\n                if (toggle) {\n                    togglePx(x, y1)\n                } else {\n                    setPx(x, y1, color)\n                }\n            }\n            for (let y = y1 + 1; y < y2 && y < HEIGHT; y++) {\n                if (toggle) {\n                    togglePx(x1, y)\n                } else {\n                    setPx(x1, y, color)\n                }\n            }\n            for (let x = x1; x <= x2 && x < WIDTH; x++) {\n                if (toggle) {\n                    togglePx(x, y2)\n                } else {\n                    setPx(x, y2, color)\n                }\n            }\n            for (let y = y1 + 1; y < y2 && y < HEIGHT; y++) {\n                if (toggle) {\n                    togglePx(x2, y)\n                } else {\n                    setPx(x2, y, color)\n                }\n            }\n        }\n    }\n\n    /**\n     * Draws line.\n     * You need to call `draw` to see the changes.\n     * @param x1 coordinate x of start of line (increases towards the right)\n     * @param y1 coordinate y of start of line (increases downwards)\n     * @param x2 coordinate x of end of line (increases towards the right)\n     * @param y2 coordinate y of end of line (increases downwards)\n     * @param color color of line\n     * @param toggle sets whether to use pixel switching instead of setting the pixel to a specific color (if `true`, `color` means nothing)\n     */\n    //% block=\"draw line from|x $x1|y $y1|to|x $x2|y $y2|color $color|toggle $toggle\"\n    //% color.defl=true\n    //% toggle.defl=false\n    //% weight=92\n    export function drawLine(x1: number, y1: number, x2: number, y2: number, color: boolean, toggle: boolean): void {\n        const line = []\n        const dx = Math.abs(x2 - x1)\n        const dy = Math.abs(y2 - y1)\n        const sx = x1 < x2 ? 1 : -1\n        const sy = y1 < y2 ? 1 : -1\n        let err = dx - dy\n        while (true) {\n            line.push([x1, y1])\n            if (x1 === x2 && y1 === y2) {\n                break\n            }\n            const e2 = 2 * err;\n            if (e2 > -dy) {\n                err -= dy\n                x1 += sx\n            }\n            if (e2 < dx) {\n                err += dx\n                y1 += sy\n            }\n        }\n        for (const pixel of line) {\n            if (toggle) {\n                togglePx(pixel[0], pixel[1])\n            } else {\n                setPx(pixel[0], pixel[1], color)\n            }\n        }\n    }\n\n    /**\n     * Draws image.\n     * You need to call `draw` to see the changes.\n     * @param image image to draw (can be `images.createImage()` or image from extension `imageio`)\n     * @param x coordinate x of upper left corner of image (increases towards the right)\n     * @param y coordinate y of upper left corner of image (increases downwards)\n     * @param color color of image (if `true`, pixel `true` in image will be drawn as `true`)\n     * @param bg sets whether empty pixels of the image are drawn (drawn with `not color`)\n     * @param toggle sets whether to use pixel switching instead of setting the pixel to a specific color (if `true`, `color` means nothing)\n     */\n    //% block=\"draw image|$image|x $x|y $y|color $color|background $bg|toggle $toggle\"\n    //% color.defl=true\n    //% bg.defl=false\n    //% toggle.defl=false\n    //% weight=100\n    //% advanced=true\n    export function drawImage(image: Image, x: number, y: number, color: boolean, bg: boolean, toggle: boolean): void {\n        if ((image != null) && (image != undefined)) {\n            for (let img_x = 0; img_x < image.width(); img_x++) {\n                for (let img_y = 0; img_y < image.height(); img_y++) {\n                    let c = image.pixel(img_x, img_y)\n                    if ((bg && !c) || (c)) {\n                        if (!color) {\n                            c = !c\n                        }\n                        if (toggle) {\n                            togglePx(x + img_x, y + img_y)\n                        } else {\n                            setPx(x + img_x, y + img_y, c)\n                        }\n                    }\n                }\n                basic.pause(1)\n            }\n        }\n    }\n\n    /**\n     * Add character for function `draw text`.\n     * For example, if you add character \"_\" and call `draw text \"a_b\"`, it will draw \"a\", then your custom character, then \"b\".\n     * Drag `character image` from the same category into field `image`.\n     * @param image character image to add to custom charset\n     * @param char character name\n     */\n    //% block=\"add character $char $image\"\n    //% advanced=true\n    //% weight=99\n    export function addChar(image: Image, char: string): void {\n        if (char != \"\" && image != null && image != undefined) {\n            char = char[0]\n            let compressedChar: number[] = []\n            for (let y = 0; y < 11; y++) {\n                let tmp = 0x00\n                for (let x = 0; x < 8; x++) {\n                    if (image.pixel(x, y)) {\n                        tmp |= 0x01 << (7 - x)\n                    }\n                }\n                compressedChar.push(tmp)\n            }\n            charset.unshift(compressedChar)\n            charsetIndex.unshift(char)\n        }\n    }\n\n    /**\n     * Create image for `add character` function.\n     */\n    //% block=\"character image\"\n    //% advanced=true\n    //% weight=98\n    //% shim=images::createImage\n    //% imageLiteral=1 imageLiteralRows=11 imageLiteralColumns=8\n    export function charImage(leds: string): Image {\n        return <Image><any>leds\n    }\n}"}]}],"snapshots":[{"timestamp":1764929994628,"editorVersion":"8.1.7","text":{"main.blocks":"<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <block type=\"pxt-on-start\"></block>\n  <block type=\"device_forever\"></block>\n</xml>","main.ts":"\n","README.md":"","pxt.json":"{\n    \"name\": \"OLED\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\"\n    ],\n    \"additionalFilePaths\": []\n}\n"}}],"shares":[],"lastSaveTime":1764930075655}